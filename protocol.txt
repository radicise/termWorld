Definitions:
long: Signed 8-bit big-endian integer
int: Signed 4-byte big-endian integer
short: Signed 2-byte big-endian integer
char: Unsigned 2-byte integer, is the Unicode value of a character which lies within Basic Multilingual Plane
byte: Octet
X-coordinate: amount of tiles right starting from 0 at leftmost
Y-coordinate, amount of tiles down starting from 0 at topmost

colorID = (data >>> 6) & 0xf


Icon defaults:
Dogs start with u+0064 or equivalent as the starting icon
Players start with u+263a or equivalent as the starting icon
Plain entities start with u+203c or equivalent as the starting icon

Default Host Server Port = 15651
Default Auth Server Port = 15652

Protocol:

Auth:


Username and password are in UTF-16BE, padded with 0x20 until 32 bytes
The `+' operator denotes the concatenation of multiple terms, the result being the bytes of the LHO followed by those of the RHO
userID and serverID are long values
Nonces are 32 bytes
Hashes are sha-256
Upon rejection, the client must quit immediately

Client -> Server: <username>
Server -> Client: <nonce0> + <serverID>
Client -> Auth: 0x63 + <userID>
Auth -> Client: 0x63 for acceptance, 0x55 for rejection due to userID not existing at the authentication server
Auth -> Client: <nonce1>
Client -> Auth: <serverID> + <nonce0> + hash(<password> + <nonce1> + <userID>)
Auth -> Client: 0x63 for acceptance, 0x55 for rejection due to the player's secret key not being verified
Auth -> Client: 0x63 for acceptance, 0x55 for rejection due to the target server not being registered with the authentication server
Auth -> Client: hash(<username> + <nonce0> + <server>.<currentSecret> + <userID>)
Client -> Server: <username> + <userid> + <the hash that the server gave>
Server -> Client: 0x63 for acceptance, 0x55 for rejection


After auth:
S -> C
int, version ID

C -> S
int, version ID

S -> C
byte, signifies if the server will accept the player. 0x63 is acceptance, 0x55 is rejection; if rejected, an int value containing the length of the rejection message in bytes is sent and then followed by the message itself, text in big-endian UTF-16; rejected players must then disconnect

S -> C
int, the length of the serialized level data in bytes, followed by the serialized level data;
Serialized level data format:
        int, version ID
        int, level width, in tiles
        int, level height, in tiles
        int, maximum possible amount of entities
        byte values of tile IDs for the level, each tile ID is 1 byte, length is width * height, order is left-to-right for each line, lines top-to-bottom
        long, level age, in animation frames
        int, player spawn X-coordinate
        int, player spawn Y-coordinate
        int, amount of serialized entities, followed by the serialized data for each entity
        Serialized entity data format:
                byte, entity type; 0 = Entity, 1 = Dog, 2 = EntityPlayer
                int, X-coordinate
                int, Y-coordinate
                long, raw data available to the entity
                short, health amount
short, animation interval time in milliseconds
int, the client's matching EntityPlayer's X-coordinate
int, the client's matching EntityPlayer's Y-coordinate
byte, 0x06
serialized entity data for the client's matching EntityPlayer

The protocol then defines the 2 different communication loops, which continue through the remainder of the client's connection:

S -> C
(pseudo-code)
[byte fID]//function ID
if (fID == 2) {
        //render the level
}
else if ((fID & 2) == 0) {//entity update
        [int xPos]//entity's X-coordinate
        [int yPos]//entity's Y-coordinate
        if ((fID & 1) == 1) {//entity icon update
                [char face]//entity's new icon
        }
        if ((fID & 4 == 4) {//entity movement
                [int newX]//entity's new X-coordinate
                [int newY]//entity's new Y-coordinate
        }
}
else {
        switch (fID) {
                case (3)://disconnection
                        [int msgSize]
                        [byte-sequence size=msgSize msg]//disconnection message, UTF-16BE
                        break;
                case (6)://new entity
                        [byte-sequence entityData]//serialized entity data
                        break;
                case (7)://remove entity
                        break;
                case (10)://tile change
                        [int tileNum]//which tile, represented by its serialized numeric position (tilePos = [int(tileNum / levelWidth), tileNum % levelWidth])
                        [byte tileID]//new value
        }
}
C -> S
Each action is represented by a different byte sent to the server
Forward-cycle tile under client's watching EntityPlayer: 0x64
Destroy tile under client's matching EntityPlayer: 0x65
Backward-cycle tile under client's watching EntityPlayer: 0x64


Auth Server Password Exchange:

lengths are 2 byte unsigned ints

Client -> Auth: 0x32
Auth -> Client: <public key length>
Auth -> Client: <auth public key>
Client -> Auth: <encrypted message length> + <client public key length>
Client -> Auth: encrypt(<password>) + <client public key>
Auth -> Client: 0x55 on invalid password, <random byte != 0x55> on success
Auth -> Client: <encrypted symmetric key length>
Auth -> Client: encrypt(<symmetric session key>)

LOOP {
        ALL COMMUNICATIONS ENCRYPTED WITH SESSION KEY
        Client -> Auth: <operation id>
        (id === 0x00) {
                CONNECTION TERMINATION
        }
        (id === 0x01) { // register new account
                Client -> Auth: <username> + <userid> + <account password>
                Auth -> Client: 0x00 if username is taken, 0x01 if user id is taken, 0x03 on success
        }
        (<unrecognized id>) {
                Auth -> Client: 0xff
        }
}